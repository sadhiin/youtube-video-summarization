{
  "media_info": {
    "video_id": "sZJvklCGn9s",
    "title": "7 Pathfinding Algorithms in 10 Minutes (Visually Explained)",
    "author": "Sigma & Syntax",
    "url": "https://youtube.com/watch?v=sZJvklCGn9s",
    "video_path": null,
    "audio_path": "data\\downloads\\1744823524_7 Pathfinding Algorithms in 10 Minutes _Visually E.mp3",
    "transcript_path": "data\\transcripts\\1744823524_7 Pathfinding Algorithms in 10 Minutes _Visually E.json"
  },
  "summary": "The transcript discusses various pathfinding algorithms in computer science, including Breadth-First Search (BFS) and Depth-First Search (DFS). \nBFS is used to find the shortest path in an unweighted graph, while DFS is used for systematic exploration and solving graph problems. \nThe discussion also covers Dijkstra's algorithm, which finds the lowest total cost path from a single starting point to all other points in a graph. \nBellman-Ford algorithm is used when the graph contains edges with negative costs and can detect negative cycles. \nA* (A-star) is an optimization of Dijkstra that's designed to find the shortest path to a specific destination. \nBi-directional search is another technique that can speed up the search process by running two simultaneous searches. \nThe Floyd-Warshall algorithm is used to find the shortest paths between all possible pairs of points in a graph. \nThese algorithms have different strengths, weaknesses, and use cases, and understanding their core principles is essential for choosing the right tool. \nThe speaker concludes by summarizing the importance of understanding pathfinding algorithms and invites viewers to support the channel. \nThe discussion provides a clear foundation for understanding the core principles of pathfinding algorithms and their applications in real-world problems.",
  "transcript_text": " Today we're taking a rapid journey through seven of the most common pathfinding algorithms and techniques used in computer science. We'll cover the core ideas behind everything from the basics to methods for handling more complex situations. Let's begin. First up is BFS or breadth-first search. This fundamental algorithm solves a basic problem, finding the path with the fewest steps or edges from a starting point to all other reachable points in an unweighted graph, meaning every step costs the same. BFS works by exploring vertices in layers of increasing distance. Starting from the source, layer 0, it visits all directly connected neighbors, layer 1, then all unvisited neighbors of layer 1, layer 2, and so on, spreading out evenly like ripples on water. To manage this layer-by-layer order, BFS efficiently uses a data structure called a queue. Because it explores layer-by-layer, BFS guarantees that the first time it reaches any point, it has found a path with the minimum possible number of edges. While BFS explores wide, another common graph traversal strategy focuses on going deep. That's DFS or depth first search. The goal of DFS is to explore as deeply as possible along one path before being forced to backtrack and explore another. It's not primarily for finding shortest paths but for systematic exploration. Starting from a vertex, DFS chooses an unvisited neighbor and continues exploring deeper from there. It repeats this, always prioritizing going deeper. When it reaches a point with no unvisited neighbors, a dead end. It backtracks to the previous vertex and tries exploring a different untouched branch. This mechanism is often implemented efficiently using recursion or a data structure called a stack to manage the backtracking process. DFS is fundamental for many graph problems like checking for cycles, testing connectivity, and performing topological sorts. Both BFS and DFS treat all steps as equal, but in reality paths often have different costs like distance or travel time. When costs vary but are non-negative, we need an algorithm like Dijkstra's. Dijkstra's algorithm is the classic method for finding the lowest total cost path from a single starting point to all other points in a graph, provided that no edge costs are negative. Imagine you're exploring a map from a starting city Dijkstra works by always identifying and choosing to travel to the next reachable location that currently appears to have the lowest total cost from the start among all locations where the best path isn finalized yet Once you finalized the shortest path to this new location, you look at its neighbors. If traveling through the location you just finalized allows you to reach any of those neighbors with a lower total cost than any route you knew before, you update your information about the best way to reach those neighbors. The algorithm repeats this process. Select the closest unfinalized location, finalize it, then update its neighbors. Gradually, the zone of locations with known shortest paths expands outwards from the start, always prioritizing the lowest cost direction currently known. The non-negative cost requirement ensures that once a path to a location is finalized, it's guaranteed to be the best one. No cheaper detour will be found later. So, what happens if the graph contains edges with negative costs, perhaps representing discounts or special conditions? Dijkstra's won't work correctly, then. This is where the Bellman-Ford algorithm comes in. This algorithm is designed to find the shortest paths from a single source, even when some edge weights are negative. Another crucial capability is its ability to detect magic loops, negative weight cycles. Cycles where continuously traversing them would infinitely decrease the total path cost. Bellman Ford operates by repeatedly performing an update process across all the edges in the graph. This process doesn't immediately finalize paths, but gradually improves the shortest path estimates. Specifically, for every connection edge from location U to location V with a weight W. The algorithm checks, is the current shortest known distance to U plus the weight W of this connection less than the current shortest known distance to V? If yes, it means a better path to V has been found by going through U, and the estimate for the best distance to V is updated. This process of reviewing and potentially updating all connections is repeated multiple times, a sufficient number of times, determined by the number of locations in the graph. After each round of checks, the shortest distance estimates have a chance to improve. Here's the key part. After the process has run for the necessary number of rounds, the algorithm performs one final checking round across all edges. If during this final check, it's still possible to find any connection that allows for an update, a reduction, in the distance to any location, the algorithm definitively concludes that the graph contains a negative weight cycle reachable from the source If no updates occur in the final round the calculated distances represent the true shortest paths Bellman Ford is more general than Dijkstra in handling negative weights but this repetitive process over all edges usually makes it slower Bellman Ford solves the negative weight problem, but sometimes we need to find a path to a specific destination more quickly in large spaces. Is there a smarter way to guide the search? That's where ASTAR comes in. ASTAR search also finds the lowest total cost path, but it's optimized for finding a path to a specific destination and is often faster than Dijkstra in these scenarios. When deciding which location to explore next, A-star doesn't just consider the actual cost already spent to reach that location from the start. It gets smarter by also adding an estimate of the remaining cost needed to get from that location to the final destination. Think of this estimate like a hunch or a compass helping the algorithm gauge if a direction seems to lead toward the goal. A-star will prioritize exploring locations where the sum of the cost already spent and the estimated remaining cost is the lowest. This helps ASTAR focus on more promising directions, like navigating a city by favoring streets that seem to head towards the district you want to reach, rather than wandering into other districts. As a result, ASTAR often finds the destination much faster. One important detail, this estimate of the remaining cost must always be optimistic, meaning it should never guess that the remaining path is longer than it actually is. Otherwise, ASTAR might miss the true shortest path. ASTAR significantly improves search efficiency. Beyond that, there's another technique that can further speed up the search, especially when both the start and end points are known. That's bi-directional search. This is an optimization technique effective for speeding up the process of finding a path between two specific points. Instead of just searching forward from the start towards the end, this technique runs two searches simultaneously. One search proceeds forward from the start point, and one proceeds backward from the destination point. These two searches expand their frontiers. When the search frontiers intersect, meaning a location is reached by both searches, a potential shortest path is found, and the algorithm can often terminate much earlier than a single one-way search. Think of it like two teams digging a tunnel from opposite ends. They typically meet in the middle faster. This technique significantly reduces the total area that needs to be explored and can be applied to speed up BFS Dijkstra and A especially in large graphs The methods we discussed focus on finding paths from a single source or between a single pair of points But what if the requirement is to know the shortest path between all possible pairs of points in the graph This problem calls for a different approach namely the Floyd-Warshall algorithm. Floyd-Warshall is the standard solution when you need to find the shortest paths between every pair of locations on a map or nodes in a network. This algorithm allows negative edge weights but requires that there are no negative weight cycles. Imagine the algorithm works very systematically. It considers each location on the map, one by one, and asks, Could using this specific location as an intermediate stop, a transit hub, improve any of the routes between any two other locations? More specifically, for each potential transit hub it considers, the algorithm rechecks all other pairs of locations. Let's call them start X and end Y. It compares two options, the current known shortest path directly from X to Y, which might already use other transit hubs considered earlier, versus the path that goes from X to the current transit hub, and then from that transit hub to Y. If going via the transit hub results in a shorter total path, then the best-known route between X and Y is updated. The algorithm repeats this process, systematically considering every location on the map as a potential transit hub and updating routes as needed. After all, locations have been considered as intermediate stops. The final result provides the shortest path distance between any two locations. This algorithm is very comprehensive because it calculates all pairs shortest paths. But for the same reason, it requires a significant number of calculation steps, especially as the number of locations grows. We've just completed a rapid tour of seven important pathfinding algorithms and techniques. BFS for the fewest steps, DFS for deep exploration, Dijkstra for non-negative costs, Bellman-Ford for handling negative costs, A-Star using smart heuristics, Bidirectional Search for optimization, and Floyd-Warshall for all pairs paths. Each method has its strengths, weaknesses, and specific use cases. Understanding their core principles allows us to choose the most appropriate and efficient tool to solve diverse, real-world pathfinding problems. The field of pathfinding algorithms continues to evolve, but hopefully this journey has provided you with a clear and understandable foundation of the core concepts. Thank you for watching! If you found this content helpful, please support the channel. See you next time!",
  "transcript_segments": [
    {
      "id": 0,
      "seek": 0,
      "start": 0,
      "end": 4.4,
      "text": " Today we're taking a rapid journey through seven of the most common pathfinding algorithms and",
      "tokens": [
        50365,
        2692,
        321,
        434,
        1940,
        257,
        7558,
        4671,
        807,
        3407,
        295,
        264,
        881,
        2689,
        3100,
        69,
        9245,
        14642,
        293,
        50585
      ],
      "temperature": 0,
      "avg_logprob": -0.08662004,
      "compression_ratio": 1.650289,
      "no_speech_prob": 1.4103901e-12
    },
    {
      "id": 1,
      "seek": 0,
      "start": 4.4,
      "end": 8.8,
      "text": " techniques used in computer science. We'll cover the core ideas behind everything from the basics",
      "tokens": [
        50585,
        7512,
        1143,
        294,
        3820,
        3497,
        13,
        492,
        603,
        2060,
        264,
        4965,
        3487,
        2261,
        1203,
        490,
        264,
        14688,
        50805
      ],
      "temperature": 0,
      "avg_logprob": -0.08662004,
      "compression_ratio": 1.650289,
      "no_speech_prob": 1.4103901e-12
    },
    {
      "id": 2,
      "seek": 0,
      "start": 8.8,
      "end": 14.32,
      "text": " to methods for handling more complex situations. Let's begin. First up is BFS or breadth-first",
      "tokens": [
        50805,
        281,
        7150,
        337,
        13175,
        544,
        3997,
        6851,
        13,
        961,
        311,
        1841,
        13,
        2386,
        493,
        307,
        363,
        29318,
        420,
        35862,
        12,
        29581,
        51081
      ],
      "temperature": 0,
      "avg_logprob": -0.08662004,
      "compression_ratio": 1.650289,
      "no_speech_prob": 1.4103901e-12
    },
    {
      "id": 3,
      "seek": 0,
      "start": 14.32,
      "end": 19.36,
      "text": " search. This fundamental algorithm solves a basic problem, finding the path with the fewest steps",
      "tokens": [
        51081,
        3164,
        13,
        639,
        8088,
        9284,
        39890,
        257,
        3875,
        1154,
        11,
        5006,
        264,
        3100,
        365,
        264,
        1326,
        377,
        4439,
        51333
      ],
      "temperature": 0,
      "avg_logprob": -0.08662004,
      "compression_ratio": 1.650289,
      "no_speech_prob": 1.4103901e-12
    },
    {
      "id": 4,
      "seek": 0,
      "start": 19.36,
      "end": 23.76,
      "text": " or edges from a starting point to all other reachable points in an unweighted graph,",
      "tokens": [
        51333,
        420,
        8819,
        490,
        257,
        2891,
        935,
        281,
        439,
        661,
        2524,
        712,
        2793,
        294,
        364,
        517,
        12329,
        292,
        4295,
        11,
        51553
      ],
      "temperature": 0,
      "avg_logprob": -0.08662004,
      "compression_ratio": 1.650289,
      "no_speech_prob": 1.4103901e-12
    },
    {
      "id": 5,
      "seek": 0,
      "start": 23.76,
      "end": 29.76,
      "text": " meaning every step costs the same. BFS works by exploring vertices in layers of increasing distance.",
      "tokens": [
        51553,
        3620,
        633,
        1823,
        5497,
        264,
        912,
        13,
        363,
        29318,
        1985,
        538,
        12736,
        32053,
        294,
        7914,
        295,
        5662,
        4560,
        13,
        51853
      ],
      "temperature": 0,
      "avg_logprob": -0.08662004,
      "compression_ratio": 1.650289,
      "no_speech_prob": 1.4103901e-12
    },
    {
      "id": 6,
      "seek": 2976,
      "start": 29.76,
      "end": 35.52,
      "text": " Starting from the source, layer 0, it visits all directly connected neighbors, layer 1,",
      "tokens": [
        50365,
        16217,
        490,
        264,
        4009,
        11,
        4583,
        1958,
        11,
        309,
        17753,
        439,
        3838,
        4582,
        12512,
        11,
        4583,
        502,
        11,
        50653
      ],
      "temperature": 0,
      "avg_logprob": -0.073381074,
      "compression_ratio": 1.6689895,
      "no_speech_prob": 5.029757e-13
    },
    {
      "id": 7,
      "seek": 2976,
      "start": 35.52,
      "end": 40.56,
      "text": " then all unvisited neighbors of layer 1, layer 2, and so on, spreading out evenly like ripples on",
      "tokens": [
        50653,
        550,
        439,
        517,
        4938,
        1226,
        12512,
        295,
        4583,
        502,
        11,
        4583,
        568,
        11,
        293,
        370,
        322,
        11,
        15232,
        484,
        17658,
        411,
        367,
        37674,
        322,
        50905
      ],
      "temperature": 0,
      "avg_logprob": -0.073381074,
      "compression_ratio": 1.6689895,
      "no_speech_prob": 5.029757e-13
    },
    {
      "id": 8,
      "seek": 2976,
      "start": 40.56,
      "end": 46.24,
      "text": " water. To manage this layer-by-layer order, BFS efficiently uses a data structure called a queue.",
      "tokens": [
        50905,
        1281,
        13,
        1407,
        3067,
        341,
        4583,
        12,
        2322,
        12,
        8376,
        260,
        1668,
        11,
        363,
        29318,
        19621,
        4960,
        257,
        1412,
        3877,
        1219,
        257,
        18639,
        13,
        51189
      ],
      "temperature": 0,
      "avg_logprob": -0.073381074,
      "compression_ratio": 1.6689895,
      "no_speech_prob": 5.029757e-13
    },
    {
      "id": 9,
      "seek": 2976,
      "start": 46.24,
      "end": 50.96,
      "text": " Because it explores layer-by-layer, BFS guarantees that the first time it reaches any point, it has",
      "tokens": [
        51189,
        1436,
        309,
        45473,
        4583,
        12,
        2322,
        12,
        8376,
        260,
        11,
        363,
        29318,
        32567,
        300,
        264,
        700,
        565,
        309,
        14235,
        604,
        935,
        11,
        309,
        575,
        51425
      ],
      "temperature": 0,
      "avg_logprob": -0.073381074,
      "compression_ratio": 1.6689895,
      "no_speech_prob": 5.029757e-13
    },
    {
      "id": 10,
      "seek": 2976,
      "start": 50.96,
      "end": 55.92,
      "text": " found a path with the minimum possible number of edges. While BFS explores wide, another common",
      "tokens": [
        51425,
        1352,
        257,
        3100,
        365,
        264,
        7285,
        1944,
        1230,
        295,
        8819,
        13,
        3987,
        363,
        29318,
        45473,
        4874,
        11,
        1071,
        2689,
        51673
      ],
      "temperature": 0,
      "avg_logprob": -0.073381074,
      "compression_ratio": 1.6689895,
      "no_speech_prob": 5.029757e-13
    },
    {
      "id": 11,
      "seek": 5592,
      "start": 55.92,
      "end": 62.32,
      "text": " graph traversal strategy focuses on going deep. That's DFS or depth first search. The goal of DFS",
      "tokens": [
        50365,
        4295,
        23149,
        304,
        5206,
        16109,
        322,
        516,
        2452,
        13,
        663,
        311,
        413,
        29318,
        420,
        7161,
        700,
        3164,
        13,
        440,
        3387,
        295,
        413,
        29318,
        50685
      ],
      "temperature": 0,
      "avg_logprob": -0.07117859,
      "compression_ratio": 1.7077465,
      "no_speech_prob": 1.011954e-12
    },
    {
      "id": 12,
      "seek": 5592,
      "start": 62.32,
      "end": 67.04,
      "text": " is to explore as deeply as possible along one path before being forced to backtrack and explore",
      "tokens": [
        50685,
        307,
        281,
        6839,
        382,
        8760,
        382,
        1944,
        2051,
        472,
        3100,
        949,
        885,
        7579,
        281,
        646,
        19466,
        293,
        6839,
        50921
      ],
      "temperature": 0,
      "avg_logprob": -0.07117859,
      "compression_ratio": 1.7077465,
      "no_speech_prob": 1.011954e-12
    },
    {
      "id": 13,
      "seek": 5592,
      "start": 67.04,
      "end": 72.56,
      "text": " another. It's not primarily for finding shortest paths but for systematic exploration. Starting",
      "tokens": [
        50921,
        1071,
        13,
        467,
        311,
        406,
        10029,
        337,
        5006,
        31875,
        14518,
        457,
        337,
        27249,
        16197,
        13,
        16217,
        51197
      ],
      "temperature": 0,
      "avg_logprob": -0.07117859,
      "compression_ratio": 1.7077465,
      "no_speech_prob": 1.011954e-12
    },
    {
      "id": 14,
      "seek": 5592,
      "start": 72.56,
      "end": 78,
      "text": " from a vertex, DFS chooses an unvisited neighbor and continues exploring deeper from there. It",
      "tokens": [
        51197,
        490,
        257,
        28162,
        11,
        413,
        29318,
        25963,
        364,
        517,
        4938,
        1226,
        5987,
        293,
        6515,
        12736,
        7731,
        490,
        456,
        13,
        467,
        51469
      ],
      "temperature": 0,
      "avg_logprob": -0.07117859,
      "compression_ratio": 1.7077465,
      "no_speech_prob": 1.011954e-12
    },
    {
      "id": 15,
      "seek": 5592,
      "start": 78,
      "end": 83.92,
      "text": " repeats this, always prioritizing going deeper. When it reaches a point with no unvisited neighbors,",
      "tokens": [
        51469,
        35038,
        341,
        11,
        1009,
        14846,
        3319,
        516,
        7731,
        13,
        1133,
        309,
        14235,
        257,
        935,
        365,
        572,
        517,
        4938,
        1226,
        12512,
        11,
        51765
      ],
      "temperature": 0,
      "avg_logprob": -0.07117859,
      "compression_ratio": 1.7077465,
      "no_speech_prob": 1.011954e-12
    },
    {
      "id": 16,
      "seek": 8392,
      "start": 83.92,
      "end": 89.2,
      "text": " a dead end. It backtracks to the previous vertex and tries exploring a different untouched branch.",
      "tokens": [
        50365,
        257,
        3116,
        917,
        13,
        467,
        646,
        6903,
        7424,
        281,
        264,
        3894,
        28162,
        293,
        9898,
        12736,
        257,
        819,
        1701,
        36740,
        9819,
        13,
        50629
      ],
      "temperature": 0,
      "avg_logprob": -0.06464596,
      "compression_ratio": 1.6254295,
      "no_speech_prob": 1.0688246e-12
    },
    {
      "id": 17,
      "seek": 8392,
      "start": 89.2,
      "end": 93.84,
      "text": " This mechanism is often implemented efficiently using recursion or a data structure called",
      "tokens": [
        50629,
        639,
        7513,
        307,
        2049,
        12270,
        19621,
        1228,
        20560,
        313,
        420,
        257,
        1412,
        3877,
        1219,
        50861
      ],
      "temperature": 0,
      "avg_logprob": -0.06464596,
      "compression_ratio": 1.6254295,
      "no_speech_prob": 1.0688246e-12
    },
    {
      "id": 18,
      "seek": 8392,
      "start": 93.84,
      "end": 98.96,
      "text": " a stack to manage the backtracking process. DFS is fundamental for many graph problems like",
      "tokens": [
        50861,
        257,
        8630,
        281,
        3067,
        264,
        646,
        6903,
        14134,
        1399,
        13,
        413,
        29318,
        307,
        8088,
        337,
        867,
        4295,
        2740,
        411,
        51117
      ],
      "temperature": 0,
      "avg_logprob": -0.06464596,
      "compression_ratio": 1.6254295,
      "no_speech_prob": 1.0688246e-12
    },
    {
      "id": 19,
      "seek": 8392,
      "start": 98.96,
      "end": 104.88,
      "text": " checking for cycles, testing connectivity, and performing topological sorts. Both BFS and DFS",
      "tokens": [
        51117,
        8568,
        337,
        17796,
        11,
        4997,
        21095,
        11,
        293,
        10205,
        1192,
        4383,
        7527,
        13,
        6767,
        363,
        29318,
        293,
        413,
        29318,
        51413
      ],
      "temperature": 0,
      "avg_logprob": -0.06464596,
      "compression_ratio": 1.6254295,
      "no_speech_prob": 1.0688246e-12
    },
    {
      "id": 20,
      "seek": 8392,
      "start": 104.88,
      "end": 110.24,
      "text": " treat all steps as equal, but in reality paths often have different costs like distance or travel",
      "tokens": [
        51413,
        2387,
        439,
        4439,
        382,
        2681,
        11,
        457,
        294,
        4103,
        14518,
        2049,
        362,
        819,
        5497,
        411,
        4560,
        420,
        3147,
        51681
      ],
      "temperature": 0,
      "avg_logprob": -0.06464596,
      "compression_ratio": 1.6254295,
      "no_speech_prob": 1.0688246e-12
    },
    {
      "id": 21,
      "seek": 11024,
      "start": 110.24,
      "end": 115.6,
      "text": " time. When costs vary but are non-negative, we need an algorithm like Dijkstra's. Dijkstra's",
      "tokens": [
        50365,
        565,
        13,
        1133,
        5497,
        10559,
        457,
        366,
        2107,
        12,
        28561,
        1166,
        11,
        321,
        643,
        364,
        9284,
        411,
        413,
        6940,
        19639,
        311,
        13,
        413,
        6940,
        19639,
        311,
        50633
      ],
      "temperature": 0,
      "avg_logprob": -0.047963027,
      "compression_ratio": 1.7619047,
      "no_speech_prob": 1.495312e-12
    },
    {
      "id": 22,
      "seek": 11024,
      "start": 115.6,
      "end": 120.88,
      "text": " algorithm is the classic method for finding the lowest total cost path from a single starting point",
      "tokens": [
        50633,
        9284,
        307,
        264,
        7230,
        3170,
        337,
        5006,
        264,
        12437,
        3217,
        2063,
        3100,
        490,
        257,
        2167,
        2891,
        935,
        50897
      ],
      "temperature": 0,
      "avg_logprob": -0.047963027,
      "compression_ratio": 1.7619047,
      "no_speech_prob": 1.495312e-12
    },
    {
      "id": 23,
      "seek": 11024,
      "start": 120.88,
      "end": 126,
      "text": " to all other points in a graph, provided that no edge costs are negative. Imagine you're exploring",
      "tokens": [
        50897,
        281,
        439,
        661,
        2793,
        294,
        257,
        4295,
        11,
        5649,
        300,
        572,
        4691,
        5497,
        366,
        3671,
        13,
        11739,
        291,
        434,
        12736,
        51153
      ],
      "temperature": 0,
      "avg_logprob": -0.047963027,
      "compression_ratio": 1.7619047,
      "no_speech_prob": 1.495312e-12
    },
    {
      "id": 24,
      "seek": 130,
      "start": 126,
      "end": 140.82526,
      "text": " a map from a starting city Dijkstra works by always identifying and choosing to travel to the next reachable location that currently appears to have the lowest total cost from the start among all locations where the best path isn finalized yet Once you finalized the shortest",
      "tokens": [
        51153,
        257,
        4471,
        490,
        257,
        2891,
        2307,
        13,
        413,
        6940,
        19639,
        311,
        1985,
        538,
        1009,
        16696,
        293,
        10875,
        281,
        3147,
        281,
        264,
        51393,
        51393,
        958,
        2524,
        712,
        4914,
        300,
        4362,
        7038,
        281,
        362,
        264,
        12437,
        3217,
        2063,
        490,
        264,
        722,
        11,
        51645,
        50633,
        3654,
        439,
        9253,
        689,
        264,
        1151,
        3100,
        1943,
        380,
        2572,
        1602,
        1939,
        13,
        3443,
        291,
        600,
        2572,
        1602,
        264,
        31875,
        50881
      ],
      "temperature": 0,
      "avg_logprob": -0.083965115,
      "compression_ratio": 1.9198606,
      "no_speech_prob": 2.2984746e-12
    },
    {
      "id": 25,
      "seek": 130,
      "start": 140.82526,
      "end": 145.62524,
      "text": " path to this new location, you look at its neighbors. If traveling through the location",
      "tokens": [
        50881,
        3100,
        281,
        341,
        777,
        4914,
        11,
        291,
        574,
        412,
        1080,
        12512,
        13,
        759,
        9712,
        807,
        264,
        4914,
        51121
      ],
      "temperature": 0,
      "avg_logprob": -0.083965115,
      "compression_ratio": 1.9198606,
      "no_speech_prob": 2.2984746e-12
    },
    {
      "id": 26,
      "seek": 130,
      "start": 145.62524,
      "end": 150.02525,
      "text": " you just finalized allows you to reach any of those neighbors with a lower total cost than any",
      "tokens": [
        51121,
        291,
        445,
        2572,
        1602,
        4045,
        291,
        281,
        2524,
        604,
        295,
        729,
        12512,
        365,
        257,
        3126,
        3217,
        2063,
        813,
        604,
        51341
      ],
      "temperature": 0,
      "avg_logprob": -0.083965115,
      "compression_ratio": 1.9198606,
      "no_speech_prob": 2.2984746e-12
    },
    {
      "id": 27,
      "seek": 130,
      "start": 150.02525,
      "end": 154.50525,
      "text": " route you knew before, you update your information about the best way to reach those neighbors.",
      "tokens": [
        51341,
        7955,
        291,
        2586,
        949,
        11,
        291,
        5623,
        428,
        1589,
        466,
        264,
        1151,
        636,
        281,
        2524,
        729,
        12512,
        13,
        51565
      ],
      "temperature": 0,
      "avg_logprob": -0.083965115,
      "compression_ratio": 1.9198606,
      "no_speech_prob": 2.2984746e-12
    },
    {
      "id": 28,
      "seek": 130,
      "start": 154.50525,
      "end": 158.74525,
      "text": " The algorithm repeats this process. Select the closest unfinalized location,",
      "tokens": [
        51565,
        440,
        9284,
        35038,
        341,
        1399,
        13,
        13638,
        264,
        13699,
        3971,
        2071,
        1602,
        4914,
        11,
        51777
      ],
      "temperature": 0,
      "avg_logprob": -0.083965115,
      "compression_ratio": 1.9198606,
      "no_speech_prob": 2.2984746e-12
    },
    {
      "id": 29,
      "seek": 2954,
      "start": 159.46524,
      "end": 164.00525,
      "text": " finalize it, then update its neighbors. Gradually, the zone of locations with known",
      "tokens": [
        50401,
        2572,
        1125,
        309,
        11,
        550,
        5623,
        1080,
        12512,
        13,
        16710,
        671,
        11,
        264,
        6668,
        295,
        9253,
        365,
        2570,
        50628
      ],
      "temperature": 0,
      "avg_logprob": -0.08442853,
      "compression_ratio": 1.6298507,
      "no_speech_prob": 6.901939e-13
    },
    {
      "id": 30,
      "seek": 2954,
      "start": 164.00525,
      "end": 169.04526,
      "text": " shortest paths expands outwards from the start, always prioritizing the lowest cost direction",
      "tokens": [
        50628,
        31875,
        14518,
        33706,
        484,
        2015,
        490,
        264,
        722,
        11,
        1009,
        14846,
        3319,
        264,
        12437,
        2063,
        3513,
        50880
      ],
      "temperature": 0,
      "avg_logprob": -0.08442853,
      "compression_ratio": 1.6298507,
      "no_speech_prob": 6.901939e-13
    },
    {
      "id": 31,
      "seek": 2954,
      "start": 169.04526,
      "end": 174.12524,
      "text": " currently known. The non-negative cost requirement ensures that once a path to a location is finalized,",
      "tokens": [
        50880,
        4362,
        2570,
        13,
        440,
        2107,
        12,
        28561,
        1166,
        2063,
        11695,
        28111,
        300,
        1564,
        257,
        3100,
        281,
        257,
        4914,
        307,
        2572,
        1602,
        11,
        51134
      ],
      "temperature": 0,
      "avg_logprob": -0.08442853,
      "compression_ratio": 1.6298507,
      "no_speech_prob": 6.901939e-13
    },
    {
      "id": 32,
      "seek": 2954,
      "start": 174.48524,
      "end": 177.94525,
      "text": " it's guaranteed to be the best one. No cheaper detour will be found later.",
      "tokens": [
        51152,
        309,
        311,
        18031,
        281,
        312,
        264,
        1151,
        472,
        13,
        883,
        12284,
        1141,
        396,
        486,
        312,
        1352,
        1780,
        13,
        51325
      ],
      "temperature": 0,
      "avg_logprob": -0.08442853,
      "compression_ratio": 1.6298507,
      "no_speech_prob": 6.901939e-13
    },
    {
      "id": 33,
      "seek": 2954,
      "start": 177.94525,
      "end": 182.88525,
      "text": " So, what happens if the graph contains edges with negative costs, perhaps representing discounts or",
      "tokens": [
        51325,
        407,
        11,
        437,
        2314,
        498,
        264,
        4295,
        8306,
        8819,
        365,
        3671,
        5497,
        11,
        4317,
        13460,
        37930,
        420,
        51572
      ],
      "temperature": 0,
      "avg_logprob": -0.08442853,
      "compression_ratio": 1.6298507,
      "no_speech_prob": 6.901939e-13
    },
    {
      "id": 34,
      "seek": 2954,
      "start": 182.88525,
      "end": 187.98524,
      "text": " special conditions? Dijkstra's won't work correctly, then. This is where the Bellman-Ford",
      "tokens": [
        51572,
        2121,
        4487,
        30,
        413,
        6940,
        19639,
        311,
        1582,
        380,
        589,
        8944,
        11,
        550,
        13,
        639,
        307,
        689,
        264,
        11485,
        1601,
        12,
        37,
        765,
        51827
      ],
      "temperature": 0,
      "avg_logprob": -0.08442853,
      "compression_ratio": 1.6298507,
      "no_speech_prob": 6.901939e-13
    },
    {
      "id": 35,
      "seek": 5878,
      "start": 187.98524,
      "end": 192.76524,
      "text": " algorithm comes in. This algorithm is designed to find the shortest paths from a single source,",
      "tokens": [
        50365,
        9284,
        1487,
        294,
        13,
        639,
        9284,
        307,
        4761,
        281,
        915,
        264,
        31875,
        14518,
        490,
        257,
        2167,
        4009,
        11,
        50604
      ],
      "temperature": 0,
      "avg_logprob": -0.07121892,
      "compression_ratio": 1.7103659,
      "no_speech_prob": 9.210602e-13
    },
    {
      "id": 36,
      "seek": 5878,
      "start": 193.20525,
      "end": 197.64525,
      "text": " even when some edge weights are negative. Another crucial capability is its ability to detect",
      "tokens": [
        50626,
        754,
        562,
        512,
        4691,
        17443,
        366,
        3671,
        13,
        3996,
        11462,
        13759,
        307,
        1080,
        3485,
        281,
        5531,
        50848
      ],
      "temperature": 0,
      "avg_logprob": -0.07121892,
      "compression_ratio": 1.7103659,
      "no_speech_prob": 9.210602e-13
    },
    {
      "id": 37,
      "seek": 5878,
      "start": 197.64525,
      "end": 202.58525,
      "text": " magic loops, negative weight cycles. Cycles where continuously traversing them would",
      "tokens": [
        50848,
        5585,
        16121,
        11,
        3671,
        3364,
        17796,
        13,
        10295,
        6520,
        689,
        15684,
        23149,
        278,
        552,
        576,
        51095
      ],
      "temperature": 0,
      "avg_logprob": -0.07121892,
      "compression_ratio": 1.7103659,
      "no_speech_prob": 9.210602e-13
    },
    {
      "id": 38,
      "seek": 5878,
      "start": 202.58525,
      "end": 207.74524,
      "text": " infinitely decrease the total path cost. Bellman Ford operates by repeatedly performing an update",
      "tokens": [
        51095,
        36227,
        11514,
        264,
        3217,
        3100,
        2063,
        13,
        11485,
        1601,
        11961,
        22577,
        538,
        18227,
        10205,
        364,
        5623,
        51353
      ],
      "temperature": 0,
      "avg_logprob": -0.07121892,
      "compression_ratio": 1.7103659,
      "no_speech_prob": 9.210602e-13
    },
    {
      "id": 39,
      "seek": 5878,
      "start": 207.74524,
      "end": 212.08525,
      "text": " process across all the edges in the graph. This process doesn't immediately finalize paths, but",
      "tokens": [
        51353,
        1399,
        2108,
        439,
        264,
        8819,
        294,
        264,
        4295,
        13,
        639,
        1399,
        1177,
        380,
        4258,
        2572,
        1125,
        14518,
        11,
        457,
        51570
      ],
      "temperature": 0,
      "avg_logprob": -0.07121892,
      "compression_ratio": 1.7103659,
      "no_speech_prob": 9.210602e-13
    },
    {
      "id": 40,
      "seek": 5878,
      "start": 212.08525,
      "end": 217.06525,
      "text": " gradually improves the shortest path estimates. Specifically, for every connection edge from",
      "tokens": [
        51570,
        13145,
        24771,
        264,
        31875,
        3100,
        20561,
        13,
        26058,
        11,
        337,
        633,
        4984,
        4691,
        490,
        51819
      ],
      "temperature": 0,
      "avg_logprob": -0.07121892,
      "compression_ratio": 1.7103659,
      "no_speech_prob": 9.210602e-13
    },
    {
      "id": 41,
      "seek": 8786,
      "start": 217.06525,
      "end": 222.52524,
      "text": " location U to location V with a weight W. The algorithm checks, is the current shortest known",
      "tokens": [
        50365,
        4914,
        624,
        281,
        4914,
        691,
        365,
        257,
        3364,
        343,
        13,
        440,
        9284,
        13834,
        11,
        307,
        264,
        2190,
        31875,
        2570,
        50638
      ],
      "temperature": 0,
      "avg_logprob": -0.06871617,
      "compression_ratio": 1.845283,
      "no_speech_prob": 1.3992165e-12
    },
    {
      "id": 42,
      "seek": 8786,
      "start": 222.52524,
      "end": 227.66525,
      "text": " distance to U plus the weight W of this connection less than the current shortest known distance to V?",
      "tokens": [
        50638,
        4560,
        281,
        624,
        1804,
        264,
        3364,
        343,
        295,
        341,
        4984,
        1570,
        813,
        264,
        2190,
        31875,
        2570,
        4560,
        281,
        691,
        30,
        50895
      ],
      "temperature": 0,
      "avg_logprob": -0.06871617,
      "compression_ratio": 1.845283,
      "no_speech_prob": 1.3992165e-12
    },
    {
      "id": 43,
      "seek": 8786,
      "start": 227.86525,
      "end": 232.76526,
      "text": " If yes, it means a better path to V has been found by going through U, and the estimate for the best",
      "tokens": [
        50905,
        759,
        2086,
        11,
        309,
        1355,
        257,
        1101,
        3100,
        281,
        691,
        575,
        668,
        1352,
        538,
        516,
        807,
        624,
        11,
        293,
        264,
        12539,
        337,
        264,
        1151,
        51150
      ],
      "temperature": 0,
      "avg_logprob": -0.06871617,
      "compression_ratio": 1.845283,
      "no_speech_prob": 1.3992165e-12
    },
    {
      "id": 44,
      "seek": 8786,
      "start": 232.76526,
      "end": 238.04526,
      "text": " distance to V is updated. This process of reviewing and potentially updating all connections is",
      "tokens": [
        51150,
        4560,
        281,
        691,
        307,
        10588,
        13,
        639,
        1399,
        295,
        19576,
        293,
        7263,
        25113,
        439,
        9271,
        307,
        51414
      ],
      "temperature": 0,
      "avg_logprob": -0.06871617,
      "compression_ratio": 1.845283,
      "no_speech_prob": 1.3992165e-12
    },
    {
      "id": 45,
      "seek": 8786,
      "start": 238.04526,
      "end": 242.82526,
      "text": " repeated multiple times, a sufficient number of times, determined by the number of locations in",
      "tokens": [
        51414,
        10477,
        3866,
        1413,
        11,
        257,
        11563,
        1230,
        295,
        1413,
        11,
        9540,
        538,
        264,
        1230,
        295,
        9253,
        294,
        51653
      ],
      "temperature": 0,
      "avg_logprob": -0.06871617,
      "compression_ratio": 1.845283,
      "no_speech_prob": 1.3992165e-12
    },
    {
      "id": 46,
      "seek": 11362,
      "start": 242.82526,
      "end": 247.24524,
      "text": " the graph. After each round of checks, the shortest distance estimates have a chance to improve.",
      "tokens": [
        50365,
        264,
        4295,
        13,
        2381,
        1184,
        3098,
        295,
        13834,
        11,
        264,
        31875,
        4560,
        20561,
        362,
        257,
        2931,
        281,
        3470,
        13,
        50586
      ],
      "temperature": 0,
      "avg_logprob": -0.081601426,
      "compression_ratio": 1.8229508,
      "no_speech_prob": 9.106664e-13
    },
    {
      "id": 47,
      "seek": 11362,
      "start": 247.38525,
      "end": 250.78525,
      "text": " Here's the key part. After the process has run for the necessary number of rounds,",
      "tokens": [
        50593,
        1692,
        311,
        264,
        2141,
        644,
        13,
        2381,
        264,
        1399,
        575,
        1190,
        337,
        264,
        4818,
        1230,
        295,
        13757,
        11,
        50763
      ],
      "temperature": 0,
      "avg_logprob": -0.081601426,
      "compression_ratio": 1.8229508,
      "no_speech_prob": 9.106664e-13
    },
    {
      "id": 48,
      "seek": 11362,
      "start": 250.78525,
      "end": 256.06525,
      "text": " the algorithm performs one final checking round across all edges. If during this final check,",
      "tokens": [
        50763,
        264,
        9284,
        26213,
        472,
        2572,
        8568,
        3098,
        2108,
        439,
        8819,
        13,
        759,
        1830,
        341,
        2572,
        1520,
        11,
        51027
      ],
      "temperature": 0,
      "avg_logprob": -0.081601426,
      "compression_ratio": 1.8229508,
      "no_speech_prob": 9.106664e-13
    },
    {
      "id": 49,
      "seek": 11362,
      "start": 256.38525,
      "end": 261.22525,
      "text": " it's still possible to find any connection that allows for an update, a reduction, in the distance",
      "tokens": [
        51043,
        309,
        311,
        920,
        1944,
        281,
        915,
        604,
        4984,
        300,
        4045,
        337,
        364,
        5623,
        11,
        257,
        11004,
        11,
        294,
        264,
        4560,
        51285
      ],
      "temperature": 0,
      "avg_logprob": -0.081601426,
      "compression_ratio": 1.8229508,
      "no_speech_prob": 9.106664e-13
    },
    {
      "id": 50,
      "seek": 11362,
      "start": 261.22525,
      "end": 265.70526,
      "text": " to any location, the algorithm definitively concludes that the graph contains a negative",
      "tokens": [
        51285,
        281,
        604,
        4914,
        11,
        264,
        9284,
        28152,
        356,
        24643,
        300,
        264,
        4295,
        8306,
        257,
        3671,
        51509
      ],
      "temperature": 0,
      "avg_logprob": -0.081601426,
      "compression_ratio": 1.8229508,
      "no_speech_prob": 9.106664e-13
    },
    {
      "id": 51,
      "seek": 266,
      "start": 265.70526,
      "end": 280.2105,
      "text": " weight cycle reachable from the source If no updates occur in the final round the calculated distances represent the true shortest paths Bellman Ford is more general than Dijkstra in handling negative weights but this repetitive process over all edges usually makes it slower Bellman Ford solves the",
      "tokens": [
        51509,
        3364,
        6586,
        2524,
        712,
        490,
        264,
        4009,
        13,
        759,
        572,
        9205,
        5160,
        294,
        264,
        2572,
        3098,
        11,
        264,
        15598,
        51724,
        50365,
        22182,
        2906,
        264,
        2074,
        31875,
        14518,
        13,
        11485,
        1601,
        11961,
        307,
        544,
        2674,
        813,
        413,
        6940,
        19639,
        294,
        13175,
        3671,
        50825,
        50825,
        17443,
        11,
        457,
        341,
        29404,
        1399,
        670,
        439,
        8819,
        2673,
        1669,
        309,
        14009,
        13,
        11485,
        1601,
        11961,
        39890,
        264,
        51075
      ],
      "temperature": 0,
      "avg_logprob": -0.0498931,
      "compression_ratio": 1.7514793,
      "no_speech_prob": 6.874176e-13
    },
    {
      "id": 52,
      "seek": 266,
      "start": 280.2105,
      "end": 285.2105,
      "text": " negative weight problem, but sometimes we need to find a path to a specific destination more quickly",
      "tokens": [
        51075,
        3671,
        3364,
        1154,
        11,
        457,
        2171,
        321,
        643,
        281,
        915,
        257,
        3100,
        281,
        257,
        2685,
        12236,
        544,
        2661,
        51325
      ],
      "temperature": 0,
      "avg_logprob": -0.0498931,
      "compression_ratio": 1.7514793,
      "no_speech_prob": 6.874176e-13
    },
    {
      "id": 53,
      "seek": 266,
      "start": 285.2105,
      "end": 290.3105,
      "text": " in large spaces. Is there a smarter way to guide the search? That's where ASTAR comes in. ASTAR",
      "tokens": [
        51325,
        294,
        2416,
        7673,
        13,
        1119,
        456,
        257,
        20294,
        636,
        281,
        5934,
        264,
        3164,
        30,
        663,
        311,
        689,
        316,
        6840,
        1899,
        1487,
        294,
        13,
        316,
        6840,
        1899,
        51580
      ],
      "temperature": 0,
      "avg_logprob": -0.0498931,
      "compression_ratio": 1.7514793,
      "no_speech_prob": 6.874176e-13
    },
    {
      "id": 54,
      "seek": 266,
      "start": 290.3105,
      "end": 295.3905,
      "text": " search also finds the lowest total cost path, but it's optimized for finding a path to a specific",
      "tokens": [
        51580,
        3164,
        611,
        10704,
        264,
        12437,
        3217,
        2063,
        3100,
        11,
        457,
        309,
        311,
        26941,
        337,
        5006,
        257,
        3100,
        281,
        257,
        2685,
        51834
      ],
      "temperature": 0,
      "avg_logprob": -0.0498931,
      "compression_ratio": 1.7514793,
      "no_speech_prob": 6.874176e-13
    },
    {
      "id": 55,
      "seek": 3204,
      "start": 295.3905,
      "end": 300.6705,
      "text": " destination and is often faster than Dijkstra in these scenarios. When deciding which location to",
      "tokens": [
        50365,
        12236,
        293,
        307,
        2049,
        4663,
        813,
        413,
        6940,
        19639,
        294,
        613,
        15077,
        13,
        1133,
        17990,
        597,
        4914,
        281,
        50629
      ],
      "temperature": 0,
      "avg_logprob": -0.050934233,
      "compression_ratio": 1.834375,
      "no_speech_prob": 7.2888993e-13
    },
    {
      "id": 56,
      "seek": 3204,
      "start": 300.6705,
      "end": 305.6305,
      "text": " explore next, A-star doesn't just consider the actual cost already spent to reach that location",
      "tokens": [
        50629,
        6839,
        958,
        11,
        316,
        12,
        9710,
        1177,
        380,
        445,
        1949,
        264,
        3539,
        2063,
        1217,
        4418,
        281,
        2524,
        300,
        4914,
        50877
      ],
      "temperature": 0,
      "avg_logprob": -0.050934233,
      "compression_ratio": 1.834375,
      "no_speech_prob": 7.2888993e-13
    },
    {
      "id": 57,
      "seek": 3204,
      "start": 305.6305,
      "end": 310.5305,
      "text": " from the start. It gets smarter by also adding an estimate of the remaining cost needed to get from",
      "tokens": [
        50877,
        490,
        264,
        722,
        13,
        467,
        2170,
        20294,
        538,
        611,
        5127,
        364,
        12539,
        295,
        264,
        8877,
        2063,
        2978,
        281,
        483,
        490,
        51122
      ],
      "temperature": 0,
      "avg_logprob": -0.050934233,
      "compression_ratio": 1.834375,
      "no_speech_prob": 7.2888993e-13
    },
    {
      "id": 58,
      "seek": 3204,
      "start": 310.5305,
      "end": 315.5305,
      "text": " that location to the final destination. Think of this estimate like a hunch or a compass helping",
      "tokens": [
        51122,
        300,
        4914,
        281,
        264,
        2572,
        12236,
        13,
        6557,
        295,
        341,
        12539,
        411,
        257,
        47630,
        420,
        257,
        10707,
        4315,
        51372
      ],
      "temperature": 0,
      "avg_logprob": -0.050934233,
      "compression_ratio": 1.834375,
      "no_speech_prob": 7.2888993e-13
    },
    {
      "id": 59,
      "seek": 3204,
      "start": 315.5305,
      "end": 320.37048,
      "text": " the algorithm gauge if a direction seems to lead toward the goal. A-star will prioritize exploring",
      "tokens": [
        51372,
        264,
        9284,
        17924,
        498,
        257,
        3513,
        2544,
        281,
        1477,
        7361,
        264,
        3387,
        13,
        316,
        12,
        9710,
        486,
        25164,
        12736,
        51614
      ],
      "temperature": 0,
      "avg_logprob": -0.050934233,
      "compression_ratio": 1.834375,
      "no_speech_prob": 7.2888993e-13
    },
    {
      "id": 60,
      "seek": 3204,
      "start": 320.37048,
      "end": 325.2305,
      "text": " locations where the sum of the cost already spent and the estimated remaining cost is the lowest.",
      "tokens": [
        51614,
        9253,
        689,
        264,
        2408,
        295,
        264,
        2063,
        1217,
        4418,
        293,
        264,
        14109,
        8877,
        2063,
        307,
        264,
        12437,
        13,
        51857
      ],
      "temperature": 0,
      "avg_logprob": -0.050934233,
      "compression_ratio": 1.834375,
      "no_speech_prob": 7.2888993e-13
    },
    {
      "id": 61,
      "seek": 6204,
      "start": 325.3905,
      "end": 334.4505,
      "text": " This helps ASTAR focus on more promising directions, like navigating a city by favoring streets that seem to head towards the district you want to reach, rather than wandering into other districts.",
      "tokens": [
        50365,
        639,
        3665,
        316,
        6840,
        1899,
        1879,
        322,
        544,
        20257,
        11095,
        11,
        411,
        32054,
        257,
        2307,
        538,
        2294,
        278,
        8481,
        300,
        1643,
        281,
        1378,
        3030,
        264,
        6566,
        291,
        528,
        281,
        2524,
        11,
        2831,
        813,
        26396,
        666,
        661,
        16815,
        13,
        50818
      ],
      "temperature": 0,
      "avg_logprob": -0.07530766,
      "compression_ratio": 1.7222222,
      "no_speech_prob": 7.974087e-13
    },
    {
      "id": 62,
      "seek": 6204,
      "start": 334.8105,
      "end": 337.8905,
      "text": " As a result, ASTAR often finds the destination much faster.",
      "tokens": [
        50836,
        1018,
        257,
        1874,
        11,
        316,
        6840,
        1899,
        2049,
        10704,
        264,
        12236,
        709,
        4663,
        13,
        50990
      ],
      "temperature": 0,
      "avg_logprob": -0.07530766,
      "compression_ratio": 1.7222222,
      "no_speech_prob": 7.974087e-13
    },
    {
      "id": 63,
      "seek": 6204,
      "start": 338.2305,
      "end": 346.1505,
      "text": " One important detail, this estimate of the remaining cost must always be optimistic, meaning it should never guess that the remaining path is longer than it actually is.",
      "tokens": [
        51007,
        1485,
        1021,
        2607,
        11,
        341,
        12539,
        295,
        264,
        8877,
        2063,
        1633,
        1009,
        312,
        19397,
        11,
        3620,
        309,
        820,
        1128,
        2041,
        300,
        264,
        8877,
        3100,
        307,
        2854,
        813,
        309,
        767,
        307,
        13,
        51403
      ],
      "temperature": 0,
      "avg_logprob": -0.07530766,
      "compression_ratio": 1.7222222,
      "no_speech_prob": 7.974087e-13
    },
    {
      "id": 64,
      "seek": 6204,
      "start": 346.3105,
      "end": 348.8905,
      "text": " Otherwise, ASTAR might miss the true shortest path.",
      "tokens": [
        51411,
        10328,
        11,
        316,
        6840,
        1899,
        1062,
        1713,
        264,
        2074,
        31875,
        3100,
        13,
        51540
      ],
      "temperature": 0,
      "avg_logprob": -0.07530766,
      "compression_ratio": 1.7222222,
      "no_speech_prob": 7.974087e-13
    },
    {
      "id": 65,
      "seek": 6204,
      "start": 349.1105,
      "end": 351.4505,
      "text": " ASTAR significantly improves search efficiency.",
      "tokens": [
        51551,
        316,
        6840,
        1899,
        10591,
        24771,
        3164,
        10493,
        13,
        51668
      ],
      "temperature": 0,
      "avg_logprob": -0.07530766,
      "compression_ratio": 1.7222222,
      "no_speech_prob": 7.974087e-13
    },
    {
      "id": 66,
      "seek": 8810,
      "start": 351.4505,
      "end": 354.9705,
      "text": " Beyond that, there's another technique that can further speed up the search,",
      "tokens": [
        50365,
        19707,
        300,
        11,
        456,
        311,
        1071,
        6532,
        300,
        393,
        3052,
        3073,
        493,
        264,
        3164,
        11,
        50541
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 67,
      "seek": 8810,
      "start": 355.2505,
      "end": 357.8105,
      "text": " especially when both the start and end points are known.",
      "tokens": [
        50555,
        2318,
        562,
        1293,
        264,
        722,
        293,
        917,
        2793,
        366,
        2570,
        13,
        50683
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 68,
      "seek": 8810,
      "start": 358.2105,
      "end": 359.7705,
      "text": " That's bi-directional search.",
      "tokens": [
        50703,
        663,
        311,
        3228,
        12,
        18267,
        41048,
        3164,
        13,
        50781
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 69,
      "seek": 8810,
      "start": 360.1105,
      "end": 365.8305,
      "text": " This is an optimization technique effective for speeding up the process of finding a path between two specific points.",
      "tokens": [
        50798,
        639,
        307,
        364,
        19618,
        6532,
        4942,
        337,
        35593,
        493,
        264,
        1399,
        295,
        5006,
        257,
        3100,
        1296,
        732,
        2685,
        2793,
        13,
        51084
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 70,
      "seek": 8810,
      "start": 366.2505,
      "end": 371.5505,
      "text": " Instead of just searching forward from the start towards the end, this technique runs two searches simultaneously.",
      "tokens": [
        51105,
        7156,
        295,
        445,
        10808,
        2128,
        490,
        264,
        722,
        3030,
        264,
        917,
        11,
        341,
        6532,
        6676,
        732,
        26701,
        16561,
        13,
        51370
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 71,
      "seek": 8810,
      "start": 372.0705,
      "end": 376.9705,
      "text": " One search proceeds forward from the start point, and one proceeds backward from the destination point.",
      "tokens": [
        51396,
        1485,
        3164,
        32280,
        2128,
        490,
        264,
        722,
        935,
        11,
        293,
        472,
        32280,
        23897,
        490,
        264,
        12236,
        935,
        13,
        51641
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 72,
      "seek": 8810,
      "start": 377.3505,
      "end": 379.43048,
      "text": " These two searches expand their frontiers.",
      "tokens": [
        51660,
        1981,
        732,
        26701,
        5268,
        641,
        1868,
        4890,
        13,
        51764
      ],
      "temperature": 0,
      "avg_logprob": -0.08701898,
      "compression_ratio": 1.902098,
      "no_speech_prob": 6.928669e-13
    },
    {
      "id": 73,
      "seek": 11608,
      "start": 379.43048,
      "end": 390.0305,
      "text": " When the search frontiers intersect, meaning a location is reached by both searches, a potential shortest path is found, and the algorithm can often terminate much earlier than a single one-way search.",
      "tokens": [
        50365,
        1133,
        264,
        3164,
        1868,
        4890,
        27815,
        11,
        3620,
        257,
        4914,
        307,
        6488,
        538,
        1293,
        26701,
        11,
        257,
        3995,
        31875,
        3100,
        307,
        1352,
        11,
        293,
        264,
        9284,
        393,
        2049,
        10761,
        473,
        709,
        3071,
        813,
        257,
        2167,
        472,
        12,
        676,
        3164,
        13,
        50895
      ],
      "temperature": 0,
      "avg_logprob": -0.06535027,
      "compression_ratio": 1.6402266,
      "no_speech_prob": 7.699321e-13
    },
    {
      "id": 74,
      "seek": 11608,
      "start": 390.2905,
      "end": 394.97052,
      "text": " Think of it like two teams digging a tunnel from opposite ends. They typically meet in the middle faster.",
      "tokens": [
        50908,
        6557,
        295,
        309,
        411,
        732,
        5491,
        17343,
        257,
        13186,
        490,
        6182,
        5314,
        13,
        814,
        5850,
        1677,
        294,
        264,
        2808,
        4663,
        13,
        51142
      ],
      "temperature": 0,
      "avg_logprob": -0.06535027,
      "compression_ratio": 1.6402266,
      "no_speech_prob": 7.699321e-13
    },
    {
      "id": 75,
      "seek": 401,
      "start": 395.3505,
      "end": 415.75574,
      "text": " This technique significantly reduces the total area that needs to be explored and can be applied to speed up BFS Dijkstra and A especially in large graphs The methods we discussed focus on finding paths from a single source or between a single pair of points But what if the requirement is to know the shortest path between all possible pairs of points in the graph This problem calls for a different approach",
      "tokens": [
        51161,
        639,
        6532,
        10591,
        18081,
        264,
        3217,
        1859,
        300,
        2203,
        281,
        312,
        24016,
        293,
        393,
        312,
        6456,
        281,
        3073,
        493,
        363,
        29318,
        11,
        413,
        6940,
        19639,
        11,
        293,
        316,
        12,
        9710,
        11,
        2318,
        294,
        2416,
        24877,
        13,
        51547,
        51547,
        440,
        7150,
        321,
        600,
        7152,
        1879,
        322,
        5006,
        14518,
        490,
        257,
        2167,
        50595,
        2167,
        4009,
        420,
        1296,
        257,
        2167,
        6119,
        295,
        2793,
        13,
        583,
        437,
        498,
        264,
        11695,
        307,
        281,
        458,
        264,
        31875,
        50841,
        50841,
        3100,
        1296,
        439,
        1944,
        15494,
        295,
        2793,
        294,
        264,
        4295,
        30,
        639,
        1154,
        5498,
        337,
        257,
        819,
        3109,
        11,
        51077
      ],
      "temperature": 0,
      "avg_logprob": -0.06585226,
      "compression_ratio": 1.7808642,
      "no_speech_prob": 1.011948e-12
    },
    {
      "id": 76,
      "seek": 401,
      "start": 416.27576,
      "end": 421.27576,
      "text": " namely the Floyd-Warshall algorithm. Floyd-Warshall is the standard solution when you need to find the",
      "tokens": [
        51103,
        20926,
        264,
        28494,
        12,
        54,
        7064,
        336,
        9284,
        13,
        28494,
        12,
        54,
        7064,
        336,
        307,
        264,
        3832,
        3827,
        562,
        291,
        643,
        281,
        915,
        264,
        51353
      ],
      "temperature": 0,
      "avg_logprob": -0.06585226,
      "compression_ratio": 1.7808642,
      "no_speech_prob": 1.011948e-12
    },
    {
      "id": 77,
      "seek": 401,
      "start": 421.27576,
      "end": 426.29575,
      "text": " shortest paths between every pair of locations on a map or nodes in a network. This algorithm",
      "tokens": [
        51353,
        31875,
        14518,
        1296,
        633,
        6119,
        295,
        9253,
        322,
        257,
        4471,
        420,
        13891,
        294,
        257,
        3209,
        13,
        639,
        9284,
        51604
      ],
      "temperature": 0,
      "avg_logprob": -0.06585226,
      "compression_ratio": 1.7808642,
      "no_speech_prob": 1.011948e-12
    },
    {
      "id": 78,
      "seek": 401,
      "start": 426.29575,
      "end": 430.01575,
      "text": " allows negative edge weights but requires that there are no negative weight cycles.",
      "tokens": [
        51604,
        4045,
        3671,
        4691,
        17443,
        457,
        7029,
        300,
        456,
        366,
        572,
        3671,
        3364,
        17796,
        13,
        51790
      ],
      "temperature": 0,
      "avg_logprob": -0.06585226,
      "compression_ratio": 1.7808642,
      "no_speech_prob": 1.011948e-12
    },
    {
      "id": 79,
      "seek": 3251,
      "start": 430.45575,
      "end": 432.51575,
      "text": " Imagine the algorithm works very systematically.",
      "tokens": [
        50387,
        11739,
        264,
        9284,
        1985,
        588,
        39531,
        13,
        50490
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 80,
      "seek": 3251,
      "start": 433.25574,
      "end": 436.39575,
      "text": " It considers each location on the map, one by one, and asks,",
      "tokens": [
        50527,
        467,
        33095,
        1184,
        4914,
        322,
        264,
        4471,
        11,
        472,
        538,
        472,
        11,
        293,
        8962,
        11,
        50684
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 81,
      "seek": 3251,
      "start": 437.07574,
      "end": 440.67575,
      "text": " Could using this specific location as an intermediate stop, a transit hub,",
      "tokens": [
        50718,
        7497,
        1228,
        341,
        2685,
        4914,
        382,
        364,
        19376,
        1590,
        11,
        257,
        17976,
        11838,
        11,
        50898
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 82,
      "seek": 3251,
      "start": 441.13574,
      "end": 443.67575,
      "text": " improve any of the routes between any two other locations?",
      "tokens": [
        50921,
        3470,
        604,
        295,
        264,
        18242,
        1296,
        604,
        732,
        661,
        9253,
        30,
        51048
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 83,
      "seek": 3251,
      "start": 444.13574,
      "end": 447.21576,
      "text": " More specifically, for each potential transit hub it considers,",
      "tokens": [
        51071,
        5048,
        4682,
        11,
        337,
        1184,
        3995,
        17976,
        11838,
        309,
        33095,
        11,
        51225
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 84,
      "seek": 3251,
      "start": 447.75574,
      "end": 450.29575,
      "text": " the algorithm rechecks all other pairs of locations.",
      "tokens": [
        51252,
        264,
        9284,
        319,
        1876,
        2761,
        439,
        661,
        15494,
        295,
        9253,
        13,
        51379
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 85,
      "seek": 3251,
      "start": 450.73575,
      "end": 452.67575,
      "text": " Let's call them start X and end Y.",
      "tokens": [
        51401,
        961,
        311,
        818,
        552,
        722,
        1783,
        293,
        917,
        398,
        13,
        51498
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 86,
      "seek": 3251,
      "start": 452.67575,
      "end": 457.29575,
      "text": " It compares two options, the current known shortest path directly from X to Y,",
      "tokens": [
        51498,
        467,
        38334,
        732,
        3956,
        11,
        264,
        2190,
        2570,
        31875,
        3100,
        3838,
        490,
        1783,
        281,
        398,
        11,
        51729
      ],
      "temperature": 0,
      "avg_logprob": -0.19527832,
      "compression_ratio": 1.7173913,
      "no_speech_prob": 7.316348e-13
    },
    {
      "id": 87,
      "seek": 5979,
      "start": 457.29575,
      "end": 460.37573,
      "text": " which might already use other transit hubs considered earlier,",
      "tokens": [
        50365,
        597,
        1062,
        1217,
        764,
        661,
        17976,
        46870,
        4888,
        3071,
        11,
        50519
      ],
      "temperature": 0,
      "avg_logprob": -0.1367209,
      "compression_ratio": 1.8684211,
      "no_speech_prob": 1.0078289e-12
    },
    {
      "id": 88,
      "seek": 5979,
      "start": 460.97574,
      "end": 465.81573,
      "text": " versus the path that goes from X to the current transit hub, and then from that transit hub to Y.",
      "tokens": [
        50549,
        5717,
        264,
        3100,
        300,
        1709,
        490,
        1783,
        281,
        264,
        2190,
        17976,
        11838,
        11,
        293,
        550,
        490,
        300,
        17976,
        11838,
        281,
        398,
        13,
        50791
      ],
      "temperature": 0,
      "avg_logprob": -0.1367209,
      "compression_ratio": 1.8684211,
      "no_speech_prob": 1.0078289e-12
    },
    {
      "id": 89,
      "seek": 5979,
      "start": 466.19574,
      "end": 472.07574,
      "text": " If going via the transit hub results in a shorter total path, then the best-known route between X and Y is updated.",
      "tokens": [
        50810,
        759,
        516,
        5766,
        264,
        17976,
        11838,
        3542,
        294,
        257,
        11639,
        3217,
        3100,
        11,
        550,
        264,
        1151,
        12,
        6861,
        7955,
        1296,
        1783,
        293,
        398,
        307,
        10588,
        13,
        51104
      ],
      "temperature": 0,
      "avg_logprob": -0.1367209,
      "compression_ratio": 1.8684211,
      "no_speech_prob": 1.0078289e-12
    },
    {
      "id": 90,
      "seek": 5979,
      "start": 472.51575,
      "end": 479.99576,
      "text": " The algorithm repeats this process, systematically considering every location on the map as a potential transit hub and updating routes as needed.",
      "tokens": [
        51126,
        440,
        9284,
        35038,
        341,
        1399,
        11,
        39531,
        8079,
        633,
        4914,
        322,
        264,
        4471,
        382,
        257,
        3995,
        17976,
        11838,
        293,
        25113,
        18242,
        382,
        2978,
        13,
        51500
      ],
      "temperature": 0,
      "avg_logprob": -0.1367209,
      "compression_ratio": 1.8684211,
      "no_speech_prob": 1.0078289e-12
    },
    {
      "id": 91,
      "seek": 5979,
      "start": 480.07574,
      "end": 483.09576,
      "text": " After all, locations have been considered as intermediate stops.",
      "tokens": [
        51504,
        2381,
        439,
        11,
        9253,
        362,
        668,
        4888,
        382,
        19376,
        10094,
        13,
        51655
      ],
      "temperature": 0,
      "avg_logprob": -0.1367209,
      "compression_ratio": 1.8684211,
      "no_speech_prob": 1.0078289e-12
    },
    {
      "id": 92,
      "seek": 5979,
      "start": 483.51575,
      "end": 487.03574,
      "text": " The final result provides the shortest path distance between any two locations.",
      "tokens": [
        51676,
        440,
        2572,
        1874,
        6417,
        264,
        31875,
        3100,
        4560,
        1296,
        604,
        732,
        9253,
        13,
        51852
      ],
      "temperature": 0,
      "avg_logprob": -0.1367209,
      "compression_ratio": 1.8684211,
      "no_speech_prob": 1.0078289e-12
    },
    {
      "id": 93,
      "seek": 8979,
      "start": 487.29575,
      "end": 491.59576,
      "text": " This algorithm is very comprehensive because it calculates all pairs shortest paths.",
      "tokens": [
        50365,
        639,
        9284,
        307,
        588,
        13914,
        570,
        309,
        4322,
        1024,
        439,
        15494,
        31875,
        14518,
        13,
        50580
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 94,
      "seek": 8979,
      "start": 492.09576,
      "end": 495.47574,
      "text": " But for the same reason, it requires a significant number of calculation steps,",
      "tokens": [
        50605,
        583,
        337,
        264,
        912,
        1778,
        11,
        309,
        7029,
        257,
        4776,
        1230,
        295,
        17108,
        4439,
        11,
        50774
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 95,
      "seek": 8979,
      "start": 495.63574,
      "end": 497.43573,
      "text": " especially as the number of locations grows.",
      "tokens": [
        50782,
        2318,
        382,
        264,
        1230,
        295,
        9253,
        13156,
        13,
        50872
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 96,
      "seek": 8979,
      "start": 497.71576,
      "end": 501.89575,
      "text": " We've just completed a rapid tour of seven important pathfinding algorithms and techniques.",
      "tokens": [
        50886,
        492,
        600,
        445,
        7365,
        257,
        7558,
        3512,
        295,
        3407,
        1021,
        3100,
        69,
        9245,
        14642,
        293,
        7512,
        13,
        51095
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 97,
      "seek": 8979,
      "start": 502.37573,
      "end": 505.93573,
      "text": " BFS for the fewest steps, DFS for deep exploration,",
      "tokens": [
        51119,
        363,
        29318,
        337,
        264,
        1326,
        377,
        4439,
        11,
        413,
        29318,
        337,
        2452,
        16197,
        11,
        51297
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 98,
      "seek": 8979,
      "start": 506.65576,
      "end": 510.13574,
      "text": " Dijkstra for non-negative costs, Bellman-Ford for handling negative costs,",
      "tokens": [
        51333,
        413,
        6940,
        19639,
        337,
        2107,
        12,
        28561,
        1166,
        5497,
        11,
        11485,
        1601,
        12,
        37,
        765,
        337,
        13175,
        3671,
        5497,
        11,
        51507
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 99,
      "seek": 8979,
      "start": 510.13574,
      "end": 511.73575,
      "text": " A-Star using smart heuristics,",
      "tokens": [
        51507,
        316,
        12,
        24659,
        1228,
        4069,
        415,
        374,
        6006,
        11,
        51587
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 100,
      "seek": 8979,
      "start": 512.4158,
      "end": 516.19574,
      "text": " Bidirectional Search for optimization, and Floyd-Warshall for all pairs paths.",
      "tokens": [
        51621,
        363,
        327,
        621,
        41048,
        17180,
        337,
        19618,
        11,
        293,
        28494,
        12,
        54,
        7064,
        336,
        337,
        439,
        15494,
        14518,
        13,
        51810
      ],
      "temperature": 0,
      "avg_logprob": -0.17907985,
      "compression_ratio": 1.7243589,
      "no_speech_prob": 8.3880515e-13
    },
    {
      "id": 101,
      "seek": 11869,
      "start": 516.19574,
      "end": 520.15576,
      "text": " Each method has its strengths, weaknesses, and specific use cases.",
      "tokens": [
        50365,
        6947,
        3170,
        575,
        1080,
        16986,
        11,
        24381,
        11,
        293,
        2685,
        764,
        3331,
        13,
        50563
      ],
      "temperature": 0,
      "avg_logprob": -0.14121939,
      "compression_ratio": 1.6496599,
      "no_speech_prob": 1.0238687e-12
    },
    {
      "id": 102,
      "seek": 11869,
      "start": 520.63574,
      "end": 528.0557,
      "text": " Understanding their core principles allows us to choose the most appropriate and efficient tool to solve diverse, real-world pathfinding problems.",
      "tokens": [
        50587,
        36858,
        641,
        4965,
        9156,
        4045,
        505,
        281,
        2826,
        264,
        881,
        6854,
        293,
        7148,
        2290,
        281,
        5039,
        9521,
        11,
        957,
        12,
        13217,
        3100,
        69,
        9245,
        2740,
        13,
        50958
      ],
      "temperature": 0,
      "avg_logprob": -0.14121939,
      "compression_ratio": 1.6496599,
      "no_speech_prob": 1.0238687e-12
    },
    {
      "id": 103,
      "seek": 11869,
      "start": 528.57574,
      "end": 536.5557,
      "text": " The field of pathfinding algorithms continues to evolve, but hopefully this journey has provided you with a clear and understandable foundation of the core concepts.",
      "tokens": [
        50984,
        440,
        2519,
        295,
        3100,
        69,
        9245,
        14642,
        6515,
        281,
        16693,
        11,
        457,
        4696,
        341,
        4671,
        575,
        5649,
        291,
        365,
        257,
        1850,
        293,
        25648,
        7030,
        295,
        264,
        4965,
        10392,
        13,
        51383
      ],
      "temperature": 0,
      "avg_logprob": -0.14121939,
      "compression_ratio": 1.6496599,
      "no_speech_prob": 1.0238687e-12
    },
    {
      "id": 104,
      "seek": 11869,
      "start": 536.89575,
      "end": 537.7357,
      "text": " Thank you for watching!",
      "tokens": [
        51400,
        1044,
        291,
        337,
        1976,
        0,
        51442
      ],
      "temperature": 0,
      "avg_logprob": -0.14121939,
      "compression_ratio": 1.6496599,
      "no_speech_prob": 1.0238687e-12
    },
    {
      "id": 105,
      "seek": 11869,
      "start": 538.31573,
      "end": 540.7958,
      "text": " If you found this content helpful, please support the channel.",
      "tokens": [
        51471,
        759,
        291,
        1352,
        341,
        2701,
        4961,
        11,
        1767,
        1406,
        264,
        2269,
        13,
        51595
      ],
      "temperature": 0,
      "avg_logprob": -0.14121939,
      "compression_ratio": 1.6496599,
      "no_speech_prob": 1.0238687e-12
    },
    {
      "id": 106,
      "seek": 11869,
      "start": 541.1157,
      "end": 541.81573,
      "text": " See you next time!",
      "tokens": [
        51611,
        3008,
        291,
        958,
        565,
        0,
        51646
      ],
      "temperature": 0,
      "avg_logprob": -0.14121939,
      "compression_ratio": 1.6496599,
      "no_speech_prob": 1.0238687e-12
    }
  ],
  "language": "English",
  "model": null,
  "created_at": "2025-04-16 23:12:28"
}