{
  "media_info": {
    "video_id": "tv-_1er1mWI",
    "title": "10 Design Patterns Explained in 10 Minutes",
    "author": "Fireship",
    "video_path": null,
    "audio_path": "/teamspace/studios/this_studio/youtube-video-summarization/data/downloads/1744690377_10 Design Patterns Explained in 10 Minutes.mp3",
    "transcript_path": "/teamspace/studios/this_studio/youtube-video-summarization/data/transcripts/1744690377_10 Design Patterns Explained in 10 Minutes.json"
  },
  "summary": "The speaker discusses software design patterns, which are approaches to solving recurring problems in programming.\nThey compare the progression of a developer's code from simple and messy to complex and beautiful, but emphasize that simplicity is often preferred for maintainability.\nThe speaker mentions the influential book \"Design Patterns\" by the Gang of Four, which categorizes 23 patterns into creational, structural, and behavioral patterns.\nThey introduce several design patterns, including Singleton, Prototype, Facade, Proxy, Iterator, Observer, Subject-Observer, Mediator, and State.\nThese patterns are used to solve common problems in programming, such as simplifying complex systems and managing event subscriptions.\nThe speaker notes that design patterns are not just algorithms to be copied and pasted, but rather require thought and understanding to implement correctly.\nThey caution against overusing design patterns, which can add unnecessary complexity to code.\nThe speaker also discusses JavaScript-specific concepts, such as prototypal inheritance and the use of `Object.create()` to create new objects based on a prototype.\nThe transcript provides examples of how these patterns can be used in programming, including the use of jQuery and Vue.js.\nOverall, the speaker emphasizes the importance of understanding design patterns to become a proficient software engineer.",
  "transcript_text": " When you first become a junior developer, your code will look like Play-Doh snakes. But as you progress to senior developer and learn about software design patterns, your code will look like the Sistine Chapel. But when you then progress to principal engineer, you'll realize that nobody wants to maintain the Sistine Chapel for a silly website and go back to making Play-Doh snakes. In today's video, you'll learn about 10 different software design patterns, along with the pros and cons of using them, which can be very subjective and controversial. One of the most influential books in the history of programming is Design Patterns by four C++ engineers called the Gang of Four. It breaks down 23 different approaches to address recurring problems that programmers face, which are categorized as creational patterns, how objects are created, structural patterns, how objects relate to each other, and behavioral patterns, how objects communicate with each other. Becoming a proficient software engineer is not about memorizing the syntax of a programming language, but rather the ability to solve problems with it. By the end of this video, you'll understand a variety of different patterns for solving problems as they relate to modern app developers. Before we get started, I want to give a big shout out to refactoring.guru. They gave me permission to use some of their graphics that explain design patterns better than anything else out there. They're based in Ukraine, and it's seriously one of the coolest programming websites on the internet. Design patterns are really interesting because they're not just like algorithms that you can copy and paste from Stack Overflow. You actually need to use your brain to implement them. It can be tempting to implement them all over the place, but when used improperly, they can add additional complexity and boilerplate to a codebase. The book is not the bible, and there are many criticisms of it. Regardless, knowing how to recognize design patterns will help you level up as a programmer. The first pattern we'll look at is Singleton, which is very easy to understand. It's a type of object that can only be instantiated once. In TypeScript, we might implement a Singleton class called Settings to represent the global app settings data. We'll give it a static instance property and then make its constructor private so that it cannot be instantiated with the new keyword. We then create a static get instance method that will check to see if the instance has already been created, and if not, it will create a new one, and that ensures that only one object can be created. That's great and all, but here's where things become a little more nuanced. In JavaScript, we have object literals and also the concept of global data, and objects are passed around by reference. We get all the same basic characteristics as this pattern by simply creating a global object. The pattern itself is really just extra boilerplate that we don't need. It's an entirely different story in C++, but the moral is to lean on your language's built-in features before implementing a fancy design pattern. Now let's take a look at the prototype pattern, which is just a fancy word for clone. If you've done object-oriented programming, you should be familiar with inheritance, where a class can be extended with a subclass. One problem with inheritance is that it can lead to a complex hierarchy of code. The prototype pattern is an alternative way to implement inheritance but instead of inheriting functionality from a class it comes from an object that already been created This creates a flat prototype chain that makes it much easier to share functionality between objects especially in a dynamic language like JavaScript which supports prototypal inheritance out of the box. Imagine we have an object named zombie. This is our prototype, but now we want to create a new object based on it that also has a name. We can do that with object create by passing the zombie as the prototype, then specify additional properties like name for the new object. The interesting thing is that if you log this object, you'll only see the name and not the eat brains method. However, if you try to call that method, it will still work. That's because JavaScript will go up the prototype chain until it reaches the root looking for any methods or properties on the parent objects. You can always get the prototype from an object by using this proto property. However, that's not a modern best practice, and instead you should use object get prototype of. Now when it comes to classes in JavaScript, prototype refers to its constructor, and that means that we can extend a class with additional functions if we want to. However, that's also generally considered a bad practice. Now let's switch gears to the builder pattern. Imagine you're running a hot dog stand, and when a customer places an order, they need to tell you everything they want in the sandwich in the constructor. That works, but it's kind of hard to keep track of all these options, and we might want to defer each step to a later point. With the builder pattern, we create the object step-by-step using methods rather than the constructor, and we could even delegate the building logic to an entirely different class. In JavaScript, we'll have each method return this, which is a reference to the object instance. That allows us to implement method chaining, where we instantiate an object, then chain methods to it, but always get the object as the return value. You'll come across this pattern frequently with libraries like jQuery, but it's gone a bit out of style in recent years. Another pattern you may come across is factory. Instead of using the new keyword to instantiate an object, you use a function or method to do it for you. That may sound trivial, but here's a practical example. Let's imagine we're building a cross-platform app that runs on both iOS and Android. They both have the same interface, but in our code, we're doing a bunch of conditional checking to determine which button to show. That's not very maintainable. Instead, we can create a subclass or function that will determine which object to instantiate. Now instead of repeating the same logic, we use the factory to determine which button should be rendered. Now we're ready to look at the first structural pattern, facade. A facade is the face of a building. Inside that building, there's all kinds of shenanigans, corruption, and complexity that the end user doesn't need to know about. A facade is basically just a simplified API to hide other low-level details in your code base. Let's imagine we have classes for the plumbing system and electrical system, and inside of them we have all kinds of complex stuff going on like pressure and voltage. The people living in the house don't need access to these low-level details, so we create a facade class that contains the low systems as dependencies but then simplifies their operation like we might combine all of the electrical and plumbing details into a single method so the end user can simply turn them on or off with a single method Almost every package that you install with JavaScript could be considered a facade in some way, like jQuery is a great example of a facade for the more annoying low-level JavaScript features. The next structural pattern we'll look at is proxy, which is just a fancy word for a substitute. Like in school, you might have a substitute teacher to replace the real thing. In programming, you can replace a target object with a proxy, but why would you ever want to do that? Well, a great case study is the reactivity system in Vue.js. In Vue, you create data, but the framework itself needs a way to intercept that data and update the UI whenever that data changes. The way Vue handles that is by replacing the original object with a proxy. A proxy takes the original object as the first argument, then a handler as the second argument, inside of which we can override methods like get and set, which allows us to run code whenever a property is accessed on the object or changed. For example, inside of set, we might tell the framework to re-render, then use reflect to update the data on the original object. The end user can now work with the proxy just like the original object, but it can trigger these side effects behind the scenes. Proxies are also commonly used when you have a very large object that would be expensive to duplicate in memory. And now we're ready to look at some behavioral patterns, starting with iterator. The iterator pattern allows you to traverse through a collection of objects. Modern languages already provide abstractions for the iterator pattern, like the for loop. When you loop over an array of items, you're using the iterator pattern. But one thing that really chaps my ass about JavaScript is that there's no built-in range function. What I wish I could do is easily iterate 10 times at a certain interval. We can actually do that fairly easily by implementing our own iterator pattern. In JavaScript, you can do that by defining an object that has a next method on it. That function needs to return an object that has a value, which would be the current value in the loop, and a done property so it knows when to finish iterating. In this case, we will keep moving on to the next step if the start value is less than the end value. But for each iteration, we will increment the start value with a step. Eventually, the start will be greater than the end, at which point we can return an object with the done property as true. And that tells JavaScript to stop iterating. Now, a cool technique here is that we can add symbol iterator to this object, which allows us to use it in a regular for of loop. At the end of the day, with iteration, you start with a collection, and then write some code that determines how to get from the beginning to the end. It's a pull-based system, unlike the next pattern we'll look at, observer, which is a push-based system. The observer pattern allows many objects to subscribe to events that are broadcast by another object. It's a one-to-many relationship. In the real world you might have a radio tower that sends out a signal then a bunch of receivers who listen in at the same time This pattern is used all over the place in app development like in Firebase when your data changes on the server all your client apps are subscribed to it and automatically updated with the latest data In our code here, I'm going to bring in the RxJS library to simplify the demonstration of this pattern. It provides a subject class, which is the data that we want to listen to. Now, once we have a subject, we can add multiple subscriptions to it. The subject will keep track of all these subscriptions and call their callback functions whenever the data changes. Experiment with this pattern right now by clicking like and subscribe on this video. Now at some later point, we can call the next method to push a new value to the subject. Whenever that happens, every subscription will be notified. Personally, I like to think of this as a loop that unfolds over the dimension of time. But now, let's move on to the mediator pattern. A mediator is like a middleman or broker. Imagine we have a class for airplane and runway. We might have multiple runways and multiple airplanes, and somehow we need to figure out if an airplane is clear to land on a given runway. Currently, to do that, all these objects would have to communicate with each other. We have a many-to-many relationship that's very dangerous both in real life and in programming. A solution is to create a mediator, like an air traffic controller, that sits between the runways and the airplanes to provide coordination and communication. Here's a more practical example. In the Express.js web framework, there is a middleware system. You have incoming requests and outgoing responses. Middleware sits in the middle by intercepting every request, like an airplane, and transforms it into the proper format for the response, the runway. It provides a separation of concerns and eliminates code duplication. And that brings us to our tenth and final design pattern, state, where an object behaves differently based on a finite number of states. In your code, you've likely used conditional logic or switch statements to handle a bunch of different possibilities based on the state or data in your application. Code like this generally doesn't scale very well. The state pattern allows you to start with one base class, then provide it with different functionality based on its internal state. The idea is related to finite state machines in libraries like XState, where the goal is to make an object's behavior predictable based on its underlying state. In this example, we have a human class that will think something different based on its mood. Currently, we're doing that with a switch statement, but another way to go about it would be to create a separate class for each possible state. Inside each class, we will have an identical method that behaves differently. Now, in the human class, we set the state as a property, and whenever that method is called, we delegate it to its current state. That means whenever the state changes, the object will behave in a completely different way. But at the same time, we don't have to change the API or use a bunch of conditional logic. I'm going to keep things simple and wrap it up there. But remember, there are a bunch of other design patterns out there to learn. Become a pro member at Fireship.io to learn how to apply patterns like this in real applications. Thanks for watching, and I will see you in the next one.",
  "transcript_segments": null,
  "created_at": "2025-04-15 04:13:08"
}